# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
  role: String
  isProtected: Boolean
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  role: StringFilter
  isProtected: BooleanFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  role: OrderDirection
  isProtected: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  role: String
  isProtected: Boolean
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
  role: String
  isProtected: Boolean
}

type Term {
  id: ID!
  termNumber: Int
  startDate: DateTime
  endDate: DateTime
  description: String
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input TermWhereUniqueInput {
  id: ID
  termNumber: Int
}

input TermWhereInput {
  AND: [TermWhereInput!]
  OR: [TermWhereInput!]
  NOT: [TermWhereInput!]
  id: IDFilter
  termNumber: IntFilter
  startDate: DateTimeFilter
  endDate: DateTimeNullableFilter
  description: StringNullableFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input TermOrderByInput {
  id: OrderDirection
  termNumber: OrderDirection
  startDate: OrderDirection
  endDate: OrderDirection
  description: OrderDirection
}

input TermUpdateInput {
  termNumber: Int
  startDate: DateTime
  endDate: DateTime
  description: String
}

input TermUpdateArgs {
  where: TermWhereUniqueInput!
  data: TermUpdateInput!
}

input TermCreateInput {
  termNumber: Int
  startDate: DateTime
  endDate: DateTime
  description: String
}

type Committee {
  id: ID!
  term: Term
  startDate: DateTime
  endDate: DateTime
  session: String
  name: String
  members(where: PeopleWhereInput! = {}, orderBy: [PeopleOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PeopleWhereUniqueInput): [People!]
  membersCount(where: PeopleWhereInput! = {}): Int
  description: String
  displayName: String
  key: String
}

input CommitteeWhereUniqueInput {
  id: ID
}

input CommitteeWhereInput {
  AND: [CommitteeWhereInput!]
  OR: [CommitteeWhereInput!]
  NOT: [CommitteeWhereInput!]
  id: IDFilter
  term: TermWhereInput
  startDate: DateTimeFilter
  endDate: DateTimeNullableFilter
  session: StringFilter
  name: StringFilter
  members: PeopleManyRelationFilter
  description: StringNullableFilter
}

input PeopleManyRelationFilter {
  every: PeopleWhereInput
  some: PeopleWhereInput
  none: PeopleWhereInput
}

input CommitteeOrderByInput {
  id: OrderDirection
  startDate: OrderDirection
  endDate: OrderDirection
  session: OrderDirection
  name: OrderDirection
  description: OrderDirection
}

input CommitteeUpdateInput {
  term: TermRelateToOneForUpdateInput
  startDate: DateTime
  endDate: DateTime
  session: String
  name: String
  members: PeopleRelateToManyForUpdateInput
  description: String
}

input TermRelateToOneForUpdateInput {
  create: TermCreateInput
  connect: TermWhereUniqueInput
  disconnect: Boolean
}

input PeopleRelateToManyForUpdateInput {
  disconnect: [PeopleWhereUniqueInput!]
  set: [PeopleWhereUniqueInput!]
  create: [PeopleCreateInput!]
  connect: [PeopleWhereUniqueInput!]
}

input CommitteeUpdateArgs {
  where: CommitteeWhereUniqueInput!
  data: CommitteeUpdateInput!
}

input CommitteeCreateInput {
  term: TermRelateToOneForCreateInput
  startDate: DateTime
  endDate: DateTime
  session: String
  name: String
  members: PeopleRelateToManyForCreateInput
  description: String
}

input TermRelateToOneForCreateInput {
  create: TermCreateInput
  connect: TermWhereUniqueInput
}

input PeopleRelateToManyForCreateInput {
  create: [PeopleCreateInput!]
  connect: [PeopleWhereUniqueInput!]
}

type People {
  id: ID!
  type: String
  name: String
  term(where: TermWhereInput! = {}, orderBy: [TermOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TermWhereUniqueInput): [Term!]
  termCount(where: TermWhereInput! = {}): Int
  party: Party
  committees(where: CommitteeWhereInput! = {}, orderBy: [CommitteeOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: CommitteeWhereUniqueInput): [Committee!]
  committeesCount(where: CommitteeWhereInput! = {}): Int
  description: String
}

input PeopleWhereUniqueInput {
  id: ID
}

input PeopleWhereInput {
  AND: [PeopleWhereInput!]
  OR: [PeopleWhereInput!]
  NOT: [PeopleWhereInput!]
  id: IDFilter
  type: StringFilter
  name: StringFilter
  term: TermManyRelationFilter
  party: PartyWhereInput
  committees: CommitteeManyRelationFilter
  description: StringFilter
}

input TermManyRelationFilter {
  every: TermWhereInput
  some: TermWhereInput
  none: TermWhereInput
}

input CommitteeManyRelationFilter {
  every: CommitteeWhereInput
  some: CommitteeWhereInput
  none: CommitteeWhereInput
}

input PeopleOrderByInput {
  id: OrderDirection
  type: OrderDirection
  name: OrderDirection
  description: OrderDirection
}

input PeopleUpdateInput {
  type: String
  name: String
  term: TermRelateToManyForUpdateInput
  party: PartyRelateToOneForUpdateInput
  committees: CommitteeRelateToManyForUpdateInput
  description: String
}

input TermRelateToManyForUpdateInput {
  disconnect: [TermWhereUniqueInput!]
  set: [TermWhereUniqueInput!]
  create: [TermCreateInput!]
  connect: [TermWhereUniqueInput!]
}

input PartyRelateToOneForUpdateInput {
  create: PartyCreateInput
  connect: PartyWhereUniqueInput
  disconnect: Boolean
}

input CommitteeRelateToManyForUpdateInput {
  disconnect: [CommitteeWhereUniqueInput!]
  set: [CommitteeWhereUniqueInput!]
  create: [CommitteeCreateInput!]
  connect: [CommitteeWhereUniqueInput!]
}

input PeopleUpdateArgs {
  where: PeopleWhereUniqueInput!
  data: PeopleUpdateInput!
}

input PeopleCreateInput {
  type: String
  name: String
  term: TermRelateToManyForCreateInput
  party: PartyRelateToOneForCreateInput
  committees: CommitteeRelateToManyForCreateInput
  description: String
}

input TermRelateToManyForCreateInput {
  create: [TermCreateInput!]
  connect: [TermWhereUniqueInput!]
}

input PartyRelateToOneForCreateInput {
  create: PartyCreateInput
  connect: PartyWhereUniqueInput
}

input CommitteeRelateToManyForCreateInput {
  create: [CommitteeCreateInput!]
  connect: [CommitteeWhereUniqueInput!]
}

type Party {
  id: ID!
  name: String
  color: String
}

input PartyWhereUniqueInput {
  id: ID
  name: String
}

input PartyWhereInput {
  AND: [PartyWhereInput!]
  OR: [PartyWhereInput!]
  NOT: [PartyWhereInput!]
  id: IDFilter
  name: StringFilter
  color: StringFilter
}

input PartyOrderByInput {
  id: OrderDirection
  name: OrderDirection
  color: OrderDirection
}

input PartyUpdateInput {
  name: String
  color: String
}

input PartyUpdateArgs {
  where: PartyWhereUniqueInput!
  data: PartyUpdateInput!
}

input PartyCreateInput {
  name: String
  color: String
}

type Government {
  id: ID!
  category: String
  name: String
  description: String
}

input GovernmentWhereUniqueInput {
  id: ID
}

input GovernmentWhereInput {
  AND: [GovernmentWhereInput!]
  OR: [GovernmentWhereInput!]
  NOT: [GovernmentWhereInput!]
  id: IDFilter
  category: StringFilter
  name: StringFilter
  description: StringNullableFilter
}

input GovernmentOrderByInput {
  id: OrderDirection
  category: OrderDirection
  name: OrderDirection
  description: OrderDirection
}

input GovernmentUpdateInput {
  category: String
  name: String
  description: String
}

input GovernmentUpdateArgs {
  where: GovernmentWhereUniqueInput!
  data: GovernmentUpdateInput!
}

input GovernmentCreateInput {
  category: String
  name: String
  description: String
}

type Budget {
  id: ID!
  government: Government
  type: String
  year: Int
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectName: String
  projectDescription: String
  budgetAmount: Float
  lastYearSettlement: Float
  budgetUrl: String
  description: String
}

input BudgetWhereUniqueInput {
  id: ID
}

input BudgetWhereInput {
  AND: [BudgetWhereInput!]
  OR: [BudgetWhereInput!]
  NOT: [BudgetWhereInput!]
  id: IDFilter
  government: GovernmentWhereInput
  type: StringFilter
  year: IntFilter
  majorCategory: StringFilter
  mediumCategory: StringFilter
  minorCategory: StringFilter
  projectName: StringNullableFilter
  projectDescription: StringNullableFilter
  budgetAmount: FloatFilter
  lastYearSettlement: FloatNullableFilter
  budgetUrl: StringNullableFilter
  description: StringNullableFilter
}

input FloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: FloatFilter
}

input FloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: FloatNullableFilter
}

input BudgetOrderByInput {
  id: OrderDirection
  type: OrderDirection
  year: OrderDirection
  majorCategory: OrderDirection
  mediumCategory: OrderDirection
  minorCategory: OrderDirection
  projectName: OrderDirection
  projectDescription: OrderDirection
  budgetAmount: OrderDirection
  lastYearSettlement: OrderDirection
  budgetUrl: OrderDirection
  description: OrderDirection
}

input BudgetUpdateInput {
  government: GovernmentRelateToOneForUpdateInput
  type: String
  year: Int
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectName: String
  projectDescription: String
  budgetAmount: Float
  lastYearSettlement: Float
  budgetUrl: String
  description: String
}

input GovernmentRelateToOneForUpdateInput {
  create: GovernmentCreateInput
  connect: GovernmentWhereUniqueInput
  disconnect: Boolean
}

input BudgetUpdateArgs {
  where: BudgetWhereUniqueInput!
  data: BudgetUpdateInput!
}

input BudgetCreateInput {
  government: GovernmentRelateToOneForCreateInput
  type: String
  year: Int
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectName: String
  projectDescription: String
  budgetAmount: Float
  lastYearSettlement: Float
  budgetUrl: String
  description: String
}

input GovernmentRelateToOneForCreateInput {
  create: GovernmentCreateInput
  connect: GovernmentWhereUniqueInput
}

type BudgetYear {
  id: ID!
  year: Int
  budgetProgress: String
  dataProgress: String
  proposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  proposalsCount(where: ProposalWhereInput! = {}): Int
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: User
  updatedBy: User
}

input BudgetYearWhereUniqueInput {
  id: ID
  year: Int
}

input BudgetYearWhereInput {
  AND: [BudgetYearWhereInput!]
  OR: [BudgetYearWhereInput!]
  NOT: [BudgetYearWhereInput!]
  id: IDFilter
  year: IntFilter
  budgetProgress: StringFilter
  dataProgress: StringFilter
  proposals: ProposalManyRelationFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
  createdBy: UserWhereInput
  updatedBy: UserWhereInput
}

input ProposalManyRelationFilter {
  every: ProposalWhereInput
  some: ProposalWhereInput
  none: ProposalWhereInput
}

input BudgetYearOrderByInput {
  id: OrderDirection
  year: OrderDirection
  budgetProgress: OrderDirection
  dataProgress: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input BudgetYearUpdateInput {
  year: Int
  budgetProgress: String
  dataProgress: String
  proposals: ProposalRelateToManyForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRelateToOneForUpdateInput
  updatedBy: UserRelateToOneForUpdateInput
}

input ProposalRelateToManyForUpdateInput {
  disconnect: [ProposalWhereUniqueInput!]
  set: [ProposalWhereUniqueInput!]
  create: [ProposalCreateInput!]
  connect: [ProposalWhereUniqueInput!]
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input BudgetYearUpdateArgs {
  where: BudgetYearWhereUniqueInput!
  data: BudgetYearUpdateInput!
}

input BudgetYearCreateInput {
  year: Int
  budgetProgress: String
  dataProgress: String
  proposals: ProposalRelateToManyForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRelateToOneForCreateInput
  updatedBy: UserRelateToOneForCreateInput
}

input ProposalRelateToManyForCreateInput {
  create: [ProposalCreateInput!]
  connect: [ProposalWhereUniqueInput!]
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type Meeting {
  id: ID!
  location: String
  type: String
  committee(where: CommitteeWhereInput! = {}, orderBy: [CommitteeOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: CommitteeWhereUniqueInput): [Committee!]
  committeeCount(where: CommitteeWhereInput! = {}): Int
  government(where: GovernmentWhereInput! = {}, orderBy: [GovernmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: GovernmentWhereUniqueInput): [Government!]
  governmentCount(where: GovernmentWhereInput! = {}): Int
  meetingDate: DateTime
  meetingRecordUrl: String
  description: String
  displayName: String
}

input MeetingWhereUniqueInput {
  id: ID
}

input MeetingWhereInput {
  AND: [MeetingWhereInput!]
  OR: [MeetingWhereInput!]
  NOT: [MeetingWhereInput!]
  id: IDFilter
  location: StringNullableFilter
  type: StringNullableFilter
  committee: CommitteeManyRelationFilter
  government: GovernmentManyRelationFilter
  meetingDate: DateTimeNullableFilter
  meetingRecordUrl: StringFilter
  description: StringFilter
}

input GovernmentManyRelationFilter {
  every: GovernmentWhereInput
  some: GovernmentWhereInput
  none: GovernmentWhereInput
}

input MeetingOrderByInput {
  id: OrderDirection
  location: OrderDirection
  type: OrderDirection
  meetingDate: OrderDirection
  meetingRecordUrl: OrderDirection
  description: OrderDirection
}

input MeetingUpdateInput {
  location: String
  type: String
  committee: CommitteeRelateToManyForUpdateInput
  government: GovernmentRelateToManyForUpdateInput
  meetingDate: DateTime
  meetingRecordUrl: String
  description: String
}

input GovernmentRelateToManyForUpdateInput {
  disconnect: [GovernmentWhereUniqueInput!]
  set: [GovernmentWhereUniqueInput!]
  create: [GovernmentCreateInput!]
  connect: [GovernmentWhereUniqueInput!]
}

input MeetingUpdateArgs {
  where: MeetingWhereUniqueInput!
  data: MeetingUpdateInput!
}

input MeetingCreateInput {
  location: String
  type: String
  committee: CommitteeRelateToManyForCreateInput
  government: GovernmentRelateToManyForCreateInput
  meetingDate: DateTime
  meetingRecordUrl: String
  description: String
}

input GovernmentRelateToManyForCreateInput {
  create: [GovernmentCreateInput!]
  connect: [GovernmentWhereUniqueInput!]
}

type Proposal {
  id: ID!
  government: Government
  meetings(where: MeetingWhereInput! = {}, orderBy: [MeetingOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MeetingWhereUniqueInput): [Meeting!]
  meetingsCount(where: MeetingWhereInput! = {}): Int
  year: BudgetYear
  mergedProposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  mergedProposalsCount(where: ProposalWhereInput! = {}): Int
  historicalProposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  historicalProposalsCount(where: ProposalWhereInput! = {}): Int
  proposers(where: PeopleWhereInput! = {}, orderBy: [PeopleOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PeopleWhereUniqueInput): [People!]
  proposersCount(where: PeopleWhereInput! = {}): Int
  coSigners(where: PeopleWhereInput! = {}, orderBy: [PeopleOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PeopleWhereUniqueInput): [People!]
  coSignersCount(where: PeopleWhereInput! = {}): Int
  proposalTypes: [ProposalProposalTypeType!]
  result: String
  reductionAmount: Float
  freezeAmount: Float
  budgetImageUrl: String
  budget: Budget
  unfreezeStatus: String
  unfreezeHistory(where: MeetingWhereInput! = {}, orderBy: [MeetingOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MeetingWhereUniqueInput): [Meeting!]
  unfreezeHistoryCount(where: MeetingWhereInput! = {}): Int
  description: String
  reason: String
  react_good: Int
  react_angry: Int
  react_whatever: Int
  react_disappoint: Int
  recognitionAnswer: String
  publishStatus: String
}

enum ProposalProposalTypeType {
  freeze
  reduce
  other
}

input ProposalWhereUniqueInput {
  id: ID
}

input ProposalWhereInput {
  AND: [ProposalWhereInput!]
  OR: [ProposalWhereInput!]
  NOT: [ProposalWhereInput!]
  id: IDFilter
  government: GovernmentWhereInput
  meetings: MeetingManyRelationFilter
  year: BudgetYearWhereInput
  mergedProposals: ProposalManyRelationFilter
  historicalProposals: ProposalManyRelationFilter
  proposers: PeopleManyRelationFilter
  coSigners: PeopleManyRelationFilter
  result: StringNullableFilter
  reductionAmount: FloatNullableFilter
  freezeAmount: FloatNullableFilter
  budgetImageUrl: StringNullableFilter
  budget: BudgetWhereInput
  unfreezeStatus: StringNullableFilter
  unfreezeHistory: MeetingManyRelationFilter
  description: StringNullableFilter
  reason: StringNullableFilter
  react_good: IntNullableFilter
  react_angry: IntNullableFilter
  react_whatever: IntNullableFilter
  react_disappoint: IntNullableFilter
  recognitionAnswer: StringNullableFilter
  publishStatus: StringNullableFilter
}

input MeetingManyRelationFilter {
  every: MeetingWhereInput
  some: MeetingWhereInput
  none: MeetingWhereInput
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input ProposalOrderByInput {
  id: OrderDirection
  result: OrderDirection
  reductionAmount: OrderDirection
  freezeAmount: OrderDirection
  budgetImageUrl: OrderDirection
  unfreezeStatus: OrderDirection
  description: OrderDirection
  reason: OrderDirection
  react_good: OrderDirection
  react_angry: OrderDirection
  react_whatever: OrderDirection
  react_disappoint: OrderDirection
  recognitionAnswer: OrderDirection
  publishStatus: OrderDirection
}

input ProposalUpdateInput {
  government: GovernmentRelateToOneForUpdateInput
  meetings: MeetingRelateToManyForUpdateInput
  year: BudgetYearRelateToOneForUpdateInput
  mergedProposals: ProposalRelateToManyForUpdateInput
  historicalProposals: ProposalRelateToManyForUpdateInput
  proposers: PeopleRelateToManyForUpdateInput
  coSigners: PeopleRelateToManyForUpdateInput
  proposalTypes: [ProposalProposalTypeType!]
  result: String
  reductionAmount: Float
  freezeAmount: Float
  budgetImageUrl: String
  budget: BudgetRelateToOneForUpdateInput
  unfreezeStatus: String
  unfreezeHistory: MeetingRelateToManyForUpdateInput
  description: String
  reason: String
  react_good: Int
  react_angry: Int
  react_whatever: Int
  react_disappoint: Int
  recognitionAnswer: String
  publishStatus: String
}

input MeetingRelateToManyForUpdateInput {
  disconnect: [MeetingWhereUniqueInput!]
  set: [MeetingWhereUniqueInput!]
  create: [MeetingCreateInput!]
  connect: [MeetingWhereUniqueInput!]
}

input BudgetYearRelateToOneForUpdateInput {
  create: BudgetYearCreateInput
  connect: BudgetYearWhereUniqueInput
  disconnect: Boolean
}

input BudgetRelateToOneForUpdateInput {
  create: BudgetCreateInput
  connect: BudgetWhereUniqueInput
  disconnect: Boolean
}

input ProposalUpdateArgs {
  where: ProposalWhereUniqueInput!
  data: ProposalUpdateInput!
}

input ProposalCreateInput {
  government: GovernmentRelateToOneForCreateInput
  meetings: MeetingRelateToManyForCreateInput
  year: BudgetYearRelateToOneForCreateInput
  mergedProposals: ProposalRelateToManyForCreateInput
  historicalProposals: ProposalRelateToManyForCreateInput
  proposers: PeopleRelateToManyForCreateInput
  coSigners: PeopleRelateToManyForCreateInput
  proposalTypes: [ProposalProposalTypeType!]
  result: String
  reductionAmount: Float
  freezeAmount: Float
  budgetImageUrl: String
  budget: BudgetRelateToOneForCreateInput
  unfreezeStatus: String
  unfreezeHistory: MeetingRelateToManyForCreateInput
  description: String
  reason: String
  react_good: Int
  react_angry: Int
  react_whatever: Int
  react_disappoint: Int
  recognitionAnswer: String
  publishStatus: String
}

input MeetingRelateToManyForCreateInput {
  create: [MeetingCreateInput!]
  connect: [MeetingWhereUniqueInput!]
}

input BudgetYearRelateToOneForCreateInput {
  create: BudgetYearCreateInput
  connect: BudgetYearWhereUniqueInput
}

input BudgetRelateToOneForCreateInput {
  create: BudgetCreateInput
  connect: BudgetWhereUniqueInput
}

type RecognitionImage {
  id: ID!
  meeting: Meeting
  imageUrl: String
  pageNumber: Int
  government: Government
  historicalProposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  historicalProposalsCount(where: ProposalWhereInput! = {}): Int
  mergedProposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  mergedProposalsCount(where: ProposalWhereInput! = {}): Int
  result: String
  verificationStatus: String
  description: String
}

input RecognitionImageWhereUniqueInput {
  id: ID
}

input RecognitionImageWhereInput {
  AND: [RecognitionImageWhereInput!]
  OR: [RecognitionImageWhereInput!]
  NOT: [RecognitionImageWhereInput!]
  id: IDFilter
  meeting: MeetingWhereInput
  imageUrl: StringFilter
  pageNumber: IntNullableFilter
  government: GovernmentWhereInput
  historicalProposals: ProposalManyRelationFilter
  mergedProposals: ProposalManyRelationFilter
  result: StringNullableFilter
  verificationStatus: StringNullableFilter
  description: StringNullableFilter
}

input RecognitionImageOrderByInput {
  id: OrderDirection
  imageUrl: OrderDirection
  pageNumber: OrderDirection
  result: OrderDirection
  verificationStatus: OrderDirection
  description: OrderDirection
}

input RecognitionImageUpdateInput {
  meeting: MeetingRelateToOneForUpdateInput
  imageUrl: String
  pageNumber: Int
  government: GovernmentRelateToOneForUpdateInput
  historicalProposals: ProposalRelateToManyForUpdateInput
  mergedProposals: ProposalRelateToManyForUpdateInput
  result: String
  verificationStatus: String
  description: String
}

input MeetingRelateToOneForUpdateInput {
  create: MeetingCreateInput
  connect: MeetingWhereUniqueInput
  disconnect: Boolean
}

input RecognitionImageUpdateArgs {
  where: RecognitionImageWhereUniqueInput!
  data: RecognitionImageUpdateInput!
}

input RecognitionImageCreateInput {
  meeting: MeetingRelateToOneForCreateInput
  imageUrl: String
  pageNumber: Int
  government: GovernmentRelateToOneForCreateInput
  historicalProposals: ProposalRelateToManyForCreateInput
  mergedProposals: ProposalRelateToManyForCreateInput
  result: String
  verificationStatus: String
  description: String
}

input MeetingRelateToOneForCreateInput {
  create: MeetingCreateInput
  connect: MeetingWhereUniqueInput
}

type RecognitionStatus {
  id: ID!
  image: RecognitionImage
  type: String
  governmentBudgetResult: String
  budgetCategoryResult: String
  budgetAmountResult: String
  budgetTypeResult: String
  reductionAmountResult: String
  freezeAmountResult: String
  proposers: String
  coSigners: String
  reason: String
  lineuserid: String
  description: String
}

input RecognitionStatusWhereUniqueInput {
  id: ID
}

input RecognitionStatusWhereInput {
  AND: [RecognitionStatusWhereInput!]
  OR: [RecognitionStatusWhereInput!]
  NOT: [RecognitionStatusWhereInput!]
  id: IDFilter
  image: RecognitionImageWhereInput
  type: StringFilter
  governmentBudgetResult: StringNullableFilter
  budgetCategoryResult: StringNullableFilter
  budgetAmountResult: StringNullableFilter
  budgetTypeResult: StringNullableFilter
  reductionAmountResult: StringNullableFilter
  freezeAmountResult: StringNullableFilter
  proposers: StringNullableFilter
  coSigners: StringNullableFilter
  reason: StringNullableFilter
  lineuserid: StringNullableFilter
  description: StringNullableFilter
}

input RecognitionStatusOrderByInput {
  id: OrderDirection
  type: OrderDirection
  governmentBudgetResult: OrderDirection
  budgetCategoryResult: OrderDirection
  budgetAmountResult: OrderDirection
  budgetTypeResult: OrderDirection
  reductionAmountResult: OrderDirection
  freezeAmountResult: OrderDirection
  proposers: OrderDirection
  coSigners: OrderDirection
  reason: OrderDirection
  lineuserid: OrderDirection
  description: OrderDirection
}

input RecognitionStatusUpdateInput {
  image: RecognitionImageRelateToOneForUpdateInput
  type: String
  governmentBudgetResult: String
  budgetCategoryResult: String
  budgetAmountResult: String
  budgetTypeResult: String
  reductionAmountResult: String
  freezeAmountResult: String
  proposers: String
  coSigners: String
  reason: String
  lineuserid: String
  description: String
}

input RecognitionImageRelateToOneForUpdateInput {
  create: RecognitionImageCreateInput
  connect: RecognitionImageWhereUniqueInput
  disconnect: Boolean
}

input RecognitionStatusUpdateArgs {
  where: RecognitionStatusWhereUniqueInput!
  data: RecognitionStatusUpdateInput!
}

input RecognitionStatusCreateInput {
  image: RecognitionImageRelateToOneForCreateInput
  type: String
  governmentBudgetResult: String
  budgetCategoryResult: String
  budgetAmountResult: String
  budgetTypeResult: String
  reductionAmountResult: String
  freezeAmountResult: String
  proposers: String
  coSigners: String
  reason: String
  lineuserid: String
  description: String
}

input RecognitionImageRelateToOneForCreateInput {
  create: RecognitionImageCreateInput
  connect: RecognitionImageWhereUniqueInput
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createTerm(data: TermCreateInput!): Term
  createTerms(data: [TermCreateInput!]!): [Term]
  updateTerm(where: TermWhereUniqueInput!, data: TermUpdateInput!): Term
  updateTerms(data: [TermUpdateArgs!]!): [Term]
  deleteTerm(where: TermWhereUniqueInput!): Term
  deleteTerms(where: [TermWhereUniqueInput!]!): [Term]
  createCommittee(data: CommitteeCreateInput!): Committee
  createCommittees(data: [CommitteeCreateInput!]!): [Committee]
  updateCommittee(where: CommitteeWhereUniqueInput!, data: CommitteeUpdateInput!): Committee
  updateCommittees(data: [CommitteeUpdateArgs!]!): [Committee]
  deleteCommittee(where: CommitteeWhereUniqueInput!): Committee
  deleteCommittees(where: [CommitteeWhereUniqueInput!]!): [Committee]
  createPeople(data: PeopleCreateInput!): People
  createPeopleList(data: [PeopleCreateInput!]!): [People]
  updatePeople(where: PeopleWhereUniqueInput!, data: PeopleUpdateInput!): People
  updatePeopleList(data: [PeopleUpdateArgs!]!): [People]
  deletePeople(where: PeopleWhereUniqueInput!): People
  deletePeopleList(where: [PeopleWhereUniqueInput!]!): [People]
  createParty(data: PartyCreateInput!): Party
  createParties(data: [PartyCreateInput!]!): [Party]
  updateParty(where: PartyWhereUniqueInput!, data: PartyUpdateInput!): Party
  updateParties(data: [PartyUpdateArgs!]!): [Party]
  deleteParty(where: PartyWhereUniqueInput!): Party
  deleteParties(where: [PartyWhereUniqueInput!]!): [Party]
  createGovernment(data: GovernmentCreateInput!): Government
  createGovernments(data: [GovernmentCreateInput!]!): [Government]
  updateGovernment(where: GovernmentWhereUniqueInput!, data: GovernmentUpdateInput!): Government
  updateGovernments(data: [GovernmentUpdateArgs!]!): [Government]
  deleteGovernment(where: GovernmentWhereUniqueInput!): Government
  deleteGovernments(where: [GovernmentWhereUniqueInput!]!): [Government]
  createBudget(data: BudgetCreateInput!): Budget
  createBudgets(data: [BudgetCreateInput!]!): [Budget]
  updateBudget(where: BudgetWhereUniqueInput!, data: BudgetUpdateInput!): Budget
  updateBudgets(data: [BudgetUpdateArgs!]!): [Budget]
  deleteBudget(where: BudgetWhereUniqueInput!): Budget
  deleteBudgets(where: [BudgetWhereUniqueInput!]!): [Budget]
  createBudgetYear(data: BudgetYearCreateInput!): BudgetYear
  createBudgetYears(data: [BudgetYearCreateInput!]!): [BudgetYear]
  updateBudgetYear(where: BudgetYearWhereUniqueInput!, data: BudgetYearUpdateInput!): BudgetYear
  updateBudgetYears(data: [BudgetYearUpdateArgs!]!): [BudgetYear]
  deleteBudgetYear(where: BudgetYearWhereUniqueInput!): BudgetYear
  deleteBudgetYears(where: [BudgetYearWhereUniqueInput!]!): [BudgetYear]
  createMeeting(data: MeetingCreateInput!): Meeting
  createMeetings(data: [MeetingCreateInput!]!): [Meeting]
  updateMeeting(where: MeetingWhereUniqueInput!, data: MeetingUpdateInput!): Meeting
  updateMeetings(data: [MeetingUpdateArgs!]!): [Meeting]
  deleteMeeting(where: MeetingWhereUniqueInput!): Meeting
  deleteMeetings(where: [MeetingWhereUniqueInput!]!): [Meeting]
  createProposal(data: ProposalCreateInput!): Proposal
  createProposals(data: [ProposalCreateInput!]!): [Proposal]
  updateProposal(where: ProposalWhereUniqueInput!, data: ProposalUpdateInput!): Proposal
  updateProposals(data: [ProposalUpdateArgs!]!): [Proposal]
  deleteProposal(where: ProposalWhereUniqueInput!): Proposal
  deleteProposals(where: [ProposalWhereUniqueInput!]!): [Proposal]
  createRecognitionImage(data: RecognitionImageCreateInput!): RecognitionImage
  createRecognitionImages(data: [RecognitionImageCreateInput!]!): [RecognitionImage]
  updateRecognitionImage(where: RecognitionImageWhereUniqueInput!, data: RecognitionImageUpdateInput!): RecognitionImage
  updateRecognitionImages(data: [RecognitionImageUpdateArgs!]!): [RecognitionImage]
  deleteRecognitionImage(where: RecognitionImageWhereUniqueInput!): RecognitionImage
  deleteRecognitionImages(where: [RecognitionImageWhereUniqueInput!]!): [RecognitionImage]
  createRecognitionStatus(data: RecognitionStatusCreateInput!): RecognitionStatus
  createRecognitionStatuses(data: [RecognitionStatusCreateInput!]!): [RecognitionStatus]
  updateRecognitionStatus(where: RecognitionStatusWhereUniqueInput!, data: RecognitionStatusUpdateInput!): RecognitionStatus
  updateRecognitionStatuses(data: [RecognitionStatusUpdateArgs!]!): [RecognitionStatus]
  deleteRecognitionStatus(where: RecognitionStatusWhereUniqueInput!): RecognitionStatus
  deleteRecognitionStatuses(where: [RecognitionStatusWhereUniqueInput!]!): [RecognitionStatus]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
  role: String
}

type Query {
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  terms(where: TermWhereInput! = {}, orderBy: [TermOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TermWhereUniqueInput): [Term!]
  term(where: TermWhereUniqueInput!): Term
  termsCount(where: TermWhereInput! = {}): Int
  committees(where: CommitteeWhereInput! = {}, orderBy: [CommitteeOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: CommitteeWhereUniqueInput): [Committee!]
  committee(where: CommitteeWhereUniqueInput!): Committee
  committeesCount(where: CommitteeWhereInput! = {}): Int
  peopleList(where: PeopleWhereInput! = {}, orderBy: [PeopleOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PeopleWhereUniqueInput): [People!]
  people(where: PeopleWhereUniqueInput!): People
  peopleListCount(where: PeopleWhereInput! = {}): Int
  parties(where: PartyWhereInput! = {}, orderBy: [PartyOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PartyWhereUniqueInput): [Party!]
  party(where: PartyWhereUniqueInput!): Party
  partiesCount(where: PartyWhereInput! = {}): Int
  governments(where: GovernmentWhereInput! = {}, orderBy: [GovernmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: GovernmentWhereUniqueInput): [Government!]
  government(where: GovernmentWhereUniqueInput!): Government
  governmentsCount(where: GovernmentWhereInput! = {}): Int
  budgets(where: BudgetWhereInput! = {}, orderBy: [BudgetOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: BudgetWhereUniqueInput): [Budget!]
  budget(where: BudgetWhereUniqueInput!): Budget
  budgetsCount(where: BudgetWhereInput! = {}): Int
  budgetYears(where: BudgetYearWhereInput! = {}, orderBy: [BudgetYearOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: BudgetYearWhereUniqueInput): [BudgetYear!]
  budgetYear(where: BudgetYearWhereUniqueInput!): BudgetYear
  budgetYearsCount(where: BudgetYearWhereInput! = {}): Int
  meetings(where: MeetingWhereInput! = {}, orderBy: [MeetingOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MeetingWhereUniqueInput): [Meeting!]
  meeting(where: MeetingWhereUniqueInput!): Meeting
  meetingsCount(where: MeetingWhereInput! = {}): Int
  proposals(where: ProposalWhereInput! = {}, orderBy: [ProposalOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProposalWhereUniqueInput): [Proposal!]
  proposal(where: ProposalWhereUniqueInput!): Proposal
  proposalsCount(where: ProposalWhereInput! = {}): Int
  recognitionImages(where: RecognitionImageWhereInput! = {}, orderBy: [RecognitionImageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: RecognitionImageWhereUniqueInput): [RecognitionImage!]
  recognitionImage(where: RecognitionImageWhereUniqueInput!): RecognitionImage
  recognitionImagesCount(where: RecognitionImageWhereInput! = {}): Int
  recognitionStatuses(where: RecognitionStatusWhereInput! = {}, orderBy: [RecognitionStatusOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: RecognitionStatusWhereUniqueInput): [RecognitionStatus!]
  recognitionStatus(where: RecognitionStatusWhereUniqueInput!): RecognitionStatus
  recognitionStatusesCount(where: RecognitionStatusWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
